'''
BSD 3-Clause License

Copyright (c) 2023 Zhennan Tu <zhennan.tu@gmail.com>

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 
3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
'''

import json
import sys
import os

NOTE = '''//Do not edit this file, it's automatically generated!
//不要修改这个文件，它是自动生成的！
'''

HEADER_INCLUDE = '''
#pragma once
#include <cstdint>
#include <memory>
#include <vector>
#include <optional>
#include <deque>
#include <google/protobuf/message_lite.h>
'''

PACKET_STRUCTURE = '''
    constexpr uint8_t kVersion2 = 2;

#pragma pack(push, 1)
    struct PacketHeader
    {
        uint32_t version : 8;
        uint32_t payload_size : 24;
        uint32_t checksum;
    };
#pragma pack(pop)

    constexpr uint32_t kMsgHeaderSize = sizeof(PacketHeader);
    static_assert(kMsgHeaderSize == 8);


    struct Message
    {
        uint32_t type;
        std::shared_ptr<google::protobuf::MessageLite> msg;
    };

    struct Packet
    {
        Packet();
        std::shared_ptr<uint8_t> raw_header;
        PacketHeader* header;
        std::shared_ptr<uint8_t> payload;
        //头部暂时都是死的
        static std::optional<Packet> create(const Message& payload, bool need_xor);
        static std::optional<Packet> create(const std::shared_ptr<uint8_t>& data, uint32_t len, bool need_xor);
    };
'''

CREATE_BY_TYPE = '    std::shared_ptr<google::protobuf::MessageLite> create_by_type(uint32_t type);'

PARSER_DECLAYRE = '''
    class Parser
    {
    public:
        Parser() = default;
        void clear();
        void push_buffer(const uint8_t* buff, uint32_t size);
        bool parse_buffer();
        std::optional<Message> pop_message();

    private:
        bool parse_net_packets();
        int parse_net_packet(const uint8_t* data, uint32_t size, ltproto::Packet& packet);
        void parse_bussiness_messages();

    private:
        std::vector<uint8_t> buffer_;
        std::deque<Packet> packets_;
        std::deque<Message> messages_;
    };
'''

NAMESPACE_START = '''
namespace ltproto
{
'''
NAMESPACE_END = '''
} // namespace ltproto
'''

NAMESPACE_TYPE_START = '''    namespace type
    {
'''
NAMESPACE_TYPE_END = '''
    } // namespace type
'''

PARSER_IMPLEMENT = '''
Packet::Packet()
    : raw_header(new uint8_t[sizeof(PacketHeader)])
    , header{ reinterpret_cast<PacketHeader*>(raw_header.get()) }
    , payload(nullptr)
{
}
std::optional<Packet> Packet::create(const Message& payload, bool need_xor)
{
    need_xor = false; // XXX
    Packet pkt{};
    pkt.header->version = kVersion2;
    pkt.header->checksum = 0;
    pkt.header->payload_size = static_cast<uint32_t>(payload.msg->ByteSizeLong()) + 4;
    pkt.payload = std::shared_ptr<uint8_t>(new uint8_t[pkt.header->payload_size]);
    *(uint32_t*)pkt.payload.get() = payload.type;
    if (payload.msg->SerializeToArray(pkt.payload.get() + 4, pkt.header->payload_size - 4)) {
        return pkt;
    }
    else {
        return std::nullopt;
    }
}

std::optional<Packet> Packet::create(const std::shared_ptr<uint8_t>& data, uint32_t len, bool need_xor)
{
    need_xor = false; // XXX
    Packet pkt{};
    pkt.header->version = kVersion2;
    pkt.header->checksum = 0;
    pkt.header->payload_size = len;
    pkt.payload = data;
    return pkt;
}

void Parser::clear()
{
    buffer_.clear();
    packets_.clear();
    messages_.clear();
}

void Parser::push_buffer(const uint8_t* buff, uint32_t size)
{
    buffer_.insert(buffer_.cend(), buff, buff + size);
}

bool Parser::parse_buffer()
{
    if (!parse_net_packets()) {
        return false;
    }
    parse_bussiness_messages();
    return true;
}

std::optional<Message> Parser::pop_message()
{
    if (messages_.empty()) {
        return std::nullopt;
    }
    else {
        auto top = messages_.front();
        messages_.pop_front();
        return top;
    }
}

bool Parser::parse_net_packets()
{
    size_t total_erase_size = 0;
    while (buffer_.size() - total_erase_size > 0) {
        ltproto::Packet packet;
        int ret_value = parse_net_packet(
            buffer_.data() + total_erase_size,
            static_cast<uint32_t>(buffer_.size() - total_erase_size),
            packet);
        if (ret_value > 0) {
            total_erase_size += ret_value;
            packets_.push_back(packet);
            continue;
        }
        else if (ret_value < 0) {
            break; // 数据不足
        }
        else if (ret_value == 0) {
            return false; // 解析异常
        }
    }

    if (buffer_.size() == total_erase_size)
        buffer_.clear();
    else
        buffer_.erase(buffer_.begin(), buffer_.begin() + total_erase_size);

    return true;
}
int Parser::parse_net_packet(const uint8_t* data, uint32_t size, ltproto::Packet& packet)
{
    if (size < ltproto::kMsgHeaderSize) {
        return -1;
    }
    packet.header = const_cast<ltproto::PacketHeader*>(reinterpret_cast<const ltproto::PacketHeader*>(data));
    // 长度是否足够一个包
    if (size < packet.header->payload_size + ltproto::kMsgHeaderSize) {
        return -1;
    }
    // 长度是否超出16MB限制
    if (size > 16 * 1024 * 1024) {
        return 0;
    }
    std::shared_ptr<uint8_t> payload{ new uint8_t[packet.header->payload_size] };
    ::memcpy(payload.get(), data + ltproto::kMsgHeaderSize, packet.header->payload_size);
    packet.payload = payload;
    return static_cast<int>(packet.header->payload_size + ltproto::kMsgHeaderSize);
}
void Parser::parse_bussiness_messages()
{
    while (!packets_.empty()) {
        auto& packet = packets_.front();
        uint32_t type = *reinterpret_cast<const uint32_t*>(packet.payload.get());
        std::shared_ptr<google::protobuf::MessageLite> msg = create_by_type(type);
        if (msg == nullptr) {
            //unknown msg type
        }
        else {
            bool success = msg->ParseFromArray(packet.payload.get() + 4, packet.header->payload_size - 4);
            if (!success) {
                //error
            }
            else {
                messages_.push_back({ type, msg });
            }

        }
        packets_.pop_front();
    }
}
'''

CPP_INCLUDE = '#include <ltproto/ltproto.h>\n'

CREATE_BY_TYPE_START = '''
std::shared_ptr<google::protobuf::MessageLite> create_by_type(uint32_t _type)
{
    using namespace type;
    switch (_type) {
'''
CREATE_BY_TYPE_END = '''    default:
        return nullptr;
    }
}
'''

id_array = []
id_set = set()
message_array = []
message_set = set()
sub_ns = []
proto_h_includes = []

def generate_forward_declare(ns: str) -> str:
    content = ' ' * 4 + f"namespace {ns}\n"
    content += ' ' * 4 + '{\n'
    for message in message_array:
        if message['ns'] == ns:
            content += ' ' * 8 + f"class {message['message']};\n"
    content += ' ' * 4 + "}\n"
    return content

def generate_id_func_declare() -> str:
    content = ''
    for message in message_array:
        content += f"{' ' * 4}uint32_t id(const std::shared_ptr<{message['ns']}::{message['message']}>&);\n"
    return content

def generate_id_func_implementation() -> str:
    content = ''
    for message in message_array:
        content += f"uint32_t id(const std::shared_ptr<{message['ns']}::{message['message']}>&)\n"
        content += "{\n"
        content += ' ' * 4 + f"return type::k{message['message']};\n"
        content += "}\n"
    return content


def generate_cpp_header() -> str:
    full_header_content:str = NOTE
    full_header_content += HEADER_INCLUDE
    full_header_content += NAMESPACE_START
    for ns in sub_ns:
        full_header_content += generate_forward_declare(ns)
    full_header_content += PACKET_STRUCTURE
    full_header_content += NAMESPACE_TYPE_START
    full_header_content += '\n'
    full_header_content += ' ' * 8 + 'constexpr uint32_t kFirstProtocol = 0;\n'
    for idx in range(0, len(id_array)):
        full_header_content += f'{" " * 8}constexpr uint32_t k{message_array[idx]["message"]} = {id_array[idx]};\n'
    full_header_content += ' ' * 8 + 'constexpr uint32_t kLastProtocol = 0xffffffff;'
    full_header_content += NAMESPACE_TYPE_END
    full_header_content += '\n\n'
    full_header_content += CREATE_BY_TYPE + '\n'
    full_header_content += generate_id_func_declare()
    full_header_content += '\n'
    full_header_content += PARSER_DECLAYRE
    full_header_content += NAMESPACE_END
    return full_header_content

def generate_cpp_cpp() -> str:
    full_cpp_content:str = NOTE + "\n"
    full_cpp_content += CPP_INCLUDE
    for include in proto_h_includes:
        full_cpp_content += include + '\n'
    full_cpp_content += '\n'
    full_cpp_content += NAMESPACE_START
    full_cpp_content += CREATE_BY_TYPE_START
    for message in message_array:
        full_cpp_content += f'{" " * 4}case k{message["message"]}:\n'
        full_cpp_content += f'{" " * 8}return std::make_shared<{message["ns"]}::{message["message"]}>();\n'
    full_cpp_content += CREATE_BY_TYPE_END + '\n'
    full_cpp_content += generate_id_func_implementation()
    full_cpp_content += PARSER_IMPLEMENT
    full_cpp_content += NAMESPACE_END
    return full_cpp_content

def parse_defines_json():
    json_file = open(os.path.dirname(__file__) + '/defines.json', encoding='utf-8')
    if json_file.closed:
        print("Can't open 'defines.json'", file=sys.stderr)
        exit(-1)

    json_obj = json.load(json_file)
    for ns in json_obj:
        sub_ns.append(ns)
        for entry in json_obj[ns]:
            id_array.append(entry['id'])
            if entry['id'] in id_set:
                print(f"Duplicate id '{entry['id']}'", file=sys.stderr)
                exit(-1)
            id_set.add(entry['id'])
            message_array.append({'ns':ns, 'message':entry['message']})
            if entry['message'] in message_set:
                print(f"Duplicate message '{entry['message']}'", file=sys.stderr)
                exit(-1)
            message_set.add(entry['message'])
            proto_h_includes.append(f'#include <ltproto/{ns}/{entry["proto"].replace("proto", "pb.h")}>')

def write_file(path: str, content: str):
    with open(path, 'w', encoding='utf-8') as f:
        f.write(content)

def main():
    parse_defines_json()
    full_header_content = generate_cpp_header()
    write_file(os.path.dirname(__file__) + '/include/ltproto/ltproto.h', full_header_content)
    full_cpp_content = generate_cpp_cpp()
    write_file(os.path.dirname(__file__) + '/src/ltproto.cpp', full_cpp_content)

main()